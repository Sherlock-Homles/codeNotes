# 中级前端面试题

## 简单难度（20%）

### 1、什么是 CSS 盒模型？简述它的组成部分。

> 盒模型：就是把 HTML 页面中的元素看作是一个矩形的盒子，也就是一个装东西的容器。
>
> 盒模型包含四部分：内容（content）、内边距（padding）也称之为补白和填充区、边框（border）、外边距（margin）

### 2、CSS 清除浮动的方式有哪些？

> 1. 使用 clearfix：clearfix 是一种使用伪元素的方式，通过在父元素上添加 `::after`伪元素，并设置 `clear:both`来清除浮动。
> 2. 使用 overflow：在父元素上设置 `overflow:hidden`或 `ovweflow:auto`，可以使父元素包含浮动元素。
> 3. 使用 display:table：在父元素上设置 `display:table`，可以使父元素包含浮动元素。
> 4. 使用 display:flow-root：在父元素上设置 `diaplay:flow-root`，可以清除浮动。
> 5. 使用 fix 布局：在父元素上使用 fix 布局，可以将子元素包含在父元素中。

### 3、var，let，const 的比较。

> 1. 作用域：var 声明的变量在函数作用域中有效，而 let 和 const 声明的变量在块级作用域中有效，即大括号 `{}`中。在块级作用域中声明的变量只在该作用域内有效，作用域外不可访问。
> 2. 变量提升：使用 var 声明变量会发生变量提升，即在函数作用域中，变量声明会被提升到函数顶部。而使用 let 和 const 声明的变量不会发生变量提升，只有在变量声明的位置之后才能访问。
> 3. 重复声明：使用 var 声明的变量可以在同一个作用域内重复声明多次，后面的声明会覆盖前面的声明。而 let 和 const 声明的变量在同一个作用域内重复声明会报错。
> 4. 赋值：使用 var、let、const 声明的变量都可以重新赋值。但使用 const 声明的变量是常量，不能改变其值的引动，即不能重新赋值。而使用 var 和 let 声明的变量可以重新赋值。

### 4、什么是事件冒泡和事件捕获？简要描述它们之间的区别。

> 1. 事件冒泡是从事件元素向上冒泡到祖先元素的过程。即事件在目标元素上触发后，会沿着 DOM 树向上传递，一直到根节点为止，期间经过的所有元素都会触发相同的事件。这就意味着，如果一个子元素上触发了时间，那么其所有的祖先元素都会依次触发同一个事件。
> 2. 事件捕获是从根节点向下捕获到目标元素的过程。即从根节点开始，沿着 DOM 树向下传递，直到目标元素为止，期间经过的所有元素都会触发相同的事件。这意味着，如果一个父元素上触发了事件，那么其子元素都会依次触发同一个事件。
> 3. 事件冒泡和事件捕获之间的主要区别在于传播方向。事件冒泡是从目标元素向上传递到根节点，而事件捕获是从根节点向下捕获到目标元素。另外，事件冒泡是默认的传播方式，而事件捕获需要通过 addEventListener 方法的第三个参数来指定。
> 4. 在实际开发中，事件冒泡和事件捕获经常被用来实现事件委托和事件处理优化。事件委托可以将事件处理函数绑定到祖先元素上，利用事件冒泡机制实现对后代元素的事件处理；事件处理优化可以根据具体的应用场景选择事件冒泡或事件捕获，避免不必要的事件处理和性能消耗

### 5、JS 有哪些数据类型。

> 1. 数字（number）：表示整数和浮点数，例如 42、3.14 等。
> 2. 字符串（string）：表示文本，例如 "hello world"、'JavaScript' 等。
> 3. 布尔值（boolean）：表示真或假，即 true 或 false。
> 4. 空值（null）：表示空或不存在的值，可以使用 null 来显式地赋值。
> 5. 未定义（undefined）：表示变量未定义或对象属性不存在，例如未初始化的变量或未赋值的属性。
> 6. 符号（symbol）：表示唯一的标识符，用于对象属性的键值或作为隐藏属性等。
> 7. 大整数（bigint）：表示任意精度整数，可以使用 n 结尾的数字字面量来定义。
> 8. 对象（object）：JavaScript 的一种复杂数据类型，对象可以包含任意数量和类型的属性，包括基本类型和其他对象类型。对象可以通过字面量、构造函数或对象字面量语法来创建。

## 中等难度（60%）

### 6、Vue 中 v-if 和 v-show 的区别。

> 1. 编译时刻不同：v-if 在编译时会将元素添加或移除 DOM，而 v-show 则会将元素的 display 属性设置为 none。
> 2. 初始渲染时不同：v-if 在初始渲染时如果条件为 false，则元素不会被渲染到 DOM 中，而 v-show 在初始渲染时始终会渲染到 DOM 中。
> 3. 更新时渲染方式不同：v-if 在条件切换时会重新渲染元素，而 v-show 切换时只会修改元素的 display 属性。
>
> 综上所述，当需要频繁切换元素的显示和隐藏时，建议使用 v-show；而当条件较少变化时，建议使用 v-if，以避免不必要的 DOM 渲染开销。

### 7、Vue 中 Computed 和 Watch 的区别。

> 1. 实现方式不同：computed 是一个计算属性，通过函数的方式返回一个计算结果，只有在依赖的数据发生变化时才会重新计算，而 watch 则是一个观察者，通过监听数据变化来执行相应的操作。
> 2. 使用场景不同：computed 适用于根据已有数据计算出新值的场景。而 watch 则适用于监听某个特定数据的变化并执行相应的操作。
> 3. 能不监听对象和数组的变化不同：computed 可以监听对象和数组的变化，大需要使用深度监听或者自定义 setter 来实现。而 watch 可以监听对象和数组的变化，并提供一些可选的配置项，例如 immediate 和 deep 等。
>
> 综上所述，computed 和 watch 都有各自的优缺点和适用场景，需要根据具体的业务需求来选择使用哪种方式来监听数据变化。

### 8、浏览器中回流和重绘的区别。

> 1. 回流（reflow）：是指当页面元素位置、大小等发生变化时，浏览器需要重新计算页面布局并重新绘制页面的过程。回流成本很高，以为它会触发整个页面的重新渲染，并且会导致其他元素的位置和大小发生变化。回流的触发方式包括以下几种：
>    - 添加、删除、修改页面元素的内容
>    - 修改页面元素的样式，例如修改宽度、高度、边距、定位等
>    - 改变页面的尺寸，例如窗口大小发生变化
> 2. 重绘（repaint）：是指当页面元素的样式（例如：颜色、背景等）发生变化时，浏览器会重新绘制页面的过程。重绘的成本较低，因为它只会重新绘制受影响的部分。重绘的触发方式包括以下几种：
>    - 修改页面元素的颜色、背景等样式属性
>    - 修改页面元素的文字样式，例如字体、大小、颜色等
>
> 因此，为了提高页面的性能，我们应该尽量避免触发回流，而在修改样式时尽量使用 CSS 动画和过渡等方式来减少重绘的次数。

### 9、vue-router 的 hash 模式和 history 模式的区别。

> - URL 格式：
>
>   1. hash 模式：URL 中以 `#`分隔，`#`后面的内容成为 hash，常用于单页面应用中。在 hash 模式下，页面跳转时，不会向服务器请求资源，所有的路由都是由前端处理。
>   2. history 模式：URL 中不会出现 `#`，而是直接以路径形式展现，常用于传统的多页面应用中。在 history 模式下，页面跳转时，会向服务器请求对应的资源，因此需要后端的支持。
>
> - 实现原理：
>
>   1. hash 模式：通过监听浏览器的 hashchange 事件，从而更新页面内容。
>   2. history 模式：通过 HTML5 的 History API，使用 oushState 和 replaceState 方法来实现路由跳转，从而更新页面内容。
>
> 需要注意的是，使用 history 模式时，需要后端服务器的支持，因为在 history 模式下，浏览器直接向服务器请求资源，而服务器需要根据请求的 URL 返回相应的资源，否则会出现 404 错误。而在 hash 模式下，所有的路由都由前端处理，服务器只需要提供一个 HTML 页面即可。

### 10、什么是事件循环？描述 JavaScript 的事件循环机制和常见问题。

> 事件循环是 JavaScript 的一种执行机制，用于处理异步代码和回调函数。
>
> JavaScript 是一种单线程语言，只能执行一个任务，而事件循环的目的就是让 JavaScript 在同一时间内能够执行多个任务，从而避免阻塞执行线程。
>
> 事件循环的基本流程：先执行同步代码，然后检查异步代码是否完成，如果完成就将回调函数放到任务队列中，等待下一次事件循环时执行。
>
> 任务队列分为宏任务和微任务两种：宏任务包括 setTimeout、setInterval、setImmediate 等。微任务包括 Promise、process.nextTick 等。在事件循环中，每次处理完所有的微任务后，会优先处理当前宏任务队列中的第一个任务，然后再次处理微任务，这个过程会不断重复，直到所有的任务执行完成。

### 11、什么是跨域？描述跨域的实现原理和解决方法。

> 跨域（Cross-Origin Resource Sharing，简称 CORS）：是指浏览器限制从一个域名的网页访问另一个域名的资源的行为。例如：一个页面通过 Ajax 向另一个域名的接口发起请求，就属于跨域操作。
>
> 跨域的实现原理是基于浏览器的同源策略（Same-Origin Policy）限制。同源策略要求一个域名下的文档或脚本只能访问同域名下的资源，不能访问其他域名的资源。同源策略的限制包括：域名、端口、协议必须完全相同。
>
> 跨域的解决方法：
>
> 1. JSONP：JSONP 是一种跨域方式，通过动态创建 script 标签，向其他域名的接口发送请求，接口返回 JavaScript 代码，然后在当前页面中执行这段代码，从而实现跨域通信。
> 2. CORS：CORS 是官方推荐的跨域解决方案，需要后端配合，在响应头中设置 Access-Control-Allow-Origin，允许指定的域名跨域访问接口。
> 3. 代理：通过在同域名下创建代理服务器，将跨域请求转发到目标服务器上，然后将响应结果返回给客户端，从而实现跨域通信。
> 4. postMessage：使用 HTML5 的 postMessage 方法，在不同的窗口之间传递消息，从而实现跨域通信。

### 12、Vue 中$nextTick 的作用是什么？

> Vue 中的$nextTick 方法用于下次 DOM 更新周期结束后指向回调函数。它可以让我们在更新完数据后等待一会在执行相关操作，以确保操作可以在最新的 DOM 上执行。

### 13、Vue 中 v-for 中 key 的作用是什么？

> 唯一标识，提高渲染性能，避免出现重复渲染，渲染错误等问题。

### 14、Vuex 中的 state，getters，mutation，actions 的作用是什么？

> 1. state：用于存储应用程序的全局状态。可以通过直接修改 state 中的数据来改变应用程序的状态。
> 2. getters：用于获取 state 中的数据。可以认为 getters 相当于 state 的计算属性，它们会根据 state 中的数据进行计算，返回一个新的值。
> 3. mutation：用来修改 state 中的数据。每个 mutation 都有一个字符串类型的事件类型和一个回调函数，当触发 mutation 时，会调用响应的回调函数来修改 state 中的数据。由于 mutation 是同步执行的，因此他们只能处理简单的数据变化。
> 4. actions：用来提交 mutation 来间接地修改 state 中的数据。由于 actions 是异步执行的，因此它们可以处理复杂的业务逻辑，例如网络请求等操作。当一个 action 被调用时，它会分发一个 mutation，然后调用相应的回调函数来执行异步操作。
>
> 综上所述，state、getters、mutations、actions 是 Vuex 中非常重要的概念，它们通过一系列的机制来管理应用程序的状态，并使得状态的变化变得可追踪、可预测和可控。

### 15、什么是闭包？简述它的作用。

> 在 JavaScript 中，闭包（Closure）是指可以访问自由变量的函数，这个函数可以访问在它定义时所在的词法作用域内的变量。
>
> 简单来说，闭包就是在函数内部定义函数，它可以访问外部函数的变量，即使外部函数已经执行完毕，这些变量依然会保存在内存中，因此闭包可以用来实现一些特殊的功能。例如：
>
> 1. 计数器：利用闭包的特性，可以定义一个计数器函数，每次调用该函数都会增加计数器的值，并返回当前的计数器值。
> 2. 封装变量：利用闭包的特性，可以定义一个函数来封装一个变量，该变量可以被多个函数共享，并且只有通过指定的函数才能修改该变量的值。
> 3. 实现模块化：利用闭包的特性，可以将代码封装到一个函数中，避免全局变量的污染，实现模块化的效果。
>
> 总之，闭包是 JavaScript 中非常重要的概念之一，它可以帮助我们解决一些复杂的问题，提高代码的可读性和可维护性。

### 16、什么是箭头函数？简述它的作用。

## 补充

### em 和 rem 区别

> em：是一种相对长度单位，它基于父元素的字体大小而定。em 的值表示当前元素的字体大小的倍数。
>
> rem：是一个根据根元素（即 html 元素）字体大小而定的单位。这意味着当使用 rem 作为单位时，它的值不会受到层次结构中任何其他元素的影响。

[前端面试都面试什么？](https://youle.zhipin.com/questions/59105e367bd5f520tnVy39y6E1U~.html)

目前高级前端面了大概半个多月了，中大厂都面过，总结如下：

js 的话事件循环，闭包，原型链，继承，es6 所有 api；

css 的话就隐藏元素的方式，元素居中，动画，bfc，兼容性怎么处理，em 和 rem 区别；

http 相关的话最重要的就是缓存，必考，其他的就是 1.0 与 2.0 的区别，或者分别说发布了哪些内容，然后就是跨域，和同源策略限制内容有哪些，如何解决等等……

算法就 bfs，dfs，递归，还有一些排序，以及基本的数据结构掌握。

原理方面，reactdiff，fiber，vue 和 react 的区别，渲染机制，优化机制。然后，性能优化分别从编译阶段和编译后来讲有哪些措施；

灵活点的，如输入网址发生了什么、你遇到过最有挑战的事情。

刚开始面会吃点亏，慢慢总结，就没啥问题了，目前技术面通过率超过百分之 90 吧，都吃透就行。
